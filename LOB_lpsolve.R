LOB_lpsolve <- function(LOBpeaklist,choose_class=NULL,use_ms2_RtF) {
  
  library(lpSolve)
  library(ggplot2)
  
### Check Inputs ###
  
  if (!class(LOBpeaklist)=="data.frame") {
    
    stop("Input 'LOBpeaklist' is not an 'data.frame' object.\n", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$match_ID)) {
    
    stop("Input data.frame does not contain a 'match_ID' column.", 
          "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$compound_name)) {
    
    stop("Input data.frame does not contain a 'compound_name' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$LOBdbase_mz)) {
    
    stop("Input data.frame does not contain a 'LOBdbase_mz' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$peakgroup_rt)) {
    
    stop("Input data.frame does not contain a 'peakgroup_rt' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_C)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_C' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_DB)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_DB' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
### Format our input in a 'run' dataframe
  return <- LOBpeaklist
  LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$degree_oxidation==0),]
  
  if (is.null(choose_class)==FALSE) {
    if(choose_class%in%unique(LOBpeaklist$species)==FALSE){
    stop("Chosen 'choose_class' does not appear in the 'species' column of data.frame.")
      }else{
    LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$species==choose_class),]}
  }else{
    LOBpeaklist <- subset(LOBpeaklist, subset = lipid_class %in% c("IP_DAG","IP_MAG","TAG"))
  }
  # Put what we need in a dataframe 
  PRErun  <- data.frame(LOBpeaklist$match_ID,
                     LOBpeaklist$compound_name,
                     LOBpeaklist$LOBdbase_mz,
                     LOBpeaklist$peakgroup_rt,
                     LOBpeaklist$FA_total_no_C,
                     LOBpeaklist$FA_total_no_DB,
                     LOBpeaklist$species)
  
  #Re-name our column names
  colnames(PRErun) <- c("match_ID",
                     "compound_name",
                     "LOBdbase_mz",
                     "peakgroup_rt",
                     "FA_total_no_C",
                     "FA_total_no_DB",
                     "species")
  
### Begin Screening
  
  for (k in 1:length(unique(PRErun$species))) {
  
  run <- PRErun[which(PRErun$species== unique(PRErun$species)[k]),]
  
  #Binary string for each point
  Binary_String <- rep(1, nrow(run)) 
  
  #Empty String we will build a restrictions from
  Empty_String <- rep(0, nrow(run)) 
  
  #Matrix of our Exclusions
  Exclusion_Matrix <- matrix(nrow = 1,ncol = nrow(run))
  
  # Run a loop to find what to exclude for each point
  for (i in 1:nrow(run)) {
    
    #Get our row
    subject <- run[i,]
    
    # Make a table to store our exclusion info
    Exclusion_Table <- run
    Exclusion_Table$Exclude <- rep(FALSE,nrow(run))
    
    #Lets sort the compounds run above and below our point in terms of rt
    lower_rt <- run[which(run$peakgroup_rt < subject$peakgroup_rt),]
    higher_rt <- run[which(run$peakgroup_rt > subject$peakgroup_rt),]
    
    #Now find ones that break the rules for lower and higher and set Exclude to TRUE in the Exclusion_Table
    
    #Exclude the lower
    lower_names <- row.names(lower_rt[lower_rt$FA_total_no_C>=subject$FA_total_no_C & lower_rt$FA_total_no_DB<=subject$FA_total_no_DB,])
    Exclusion_Table[lower_names,"Exclude"] <- TRUE
    #Exclude the higher
    higher_names <- row.names(higher_rt[higher_rt$FA_total_no_C<=subject$FA_total_no_C & higher_rt$FA_total_no_DB>=subject$FA_total_no_DB,])
    Exclusion_Table[higher_names,"Exclude"] <- TRUE
    #Exclude the compounds with the same name
    Exclusion_Table[which(Exclusion_Table$compound_name==subject$compound_name),"Exclude"] <- TRUE
    
    Exclusion_String <- Empty_String
    
    for (j in 1:nrow(run)) {
      if(j!=i){
        if(Exclusion_Table[j,"Exclude"]==TRUE){
          Exclusion_String <- Empty_String
          Exclusion_String[j]<-1
          Exclusion_String[i]<-1
          Exclusion_Matrix <- rbind(Exclusion_Matrix,Exclusion_String)
          rownames(Exclusion_Matrix) <- NULL
          Exclusion_Matrix <- unique(Exclusion_Matrix)
        }
      }
      cat("\r")
      flush.console()
      cat("Writing rules for",as.character(unique(PRErun$species)[k]),"compound number",i,"of",nrow(run),". Number of Rules created:",nrow(Exclusion_Matrix),"...")
    }
  }
  cat(" Done")
  Final_Exclusion_Matrix <- Exclusion_Matrix[-1,]
  
  if(is.null(nrow(Final_Exclusion_Matrix))){
    cat("\nCompound class to small or any lacks noise to screen.")
  }else{
  
  #time to screen
  dir <- rep("<=", nrow(Final_Exclusion_Matrix)) # all constraints '<='
  
  rhs <- rep(1, nrow(Final_Exclusion_Matrix)) # all right hand sides = 1
  
  #all.bin for binary. Set Solution number high to get all solutions.
  
  
  cat("\nApplying lpSolve algorythm...")
  sol <- lpSolve::lp("max", Binary_String, Final_Exclusion_Matrix, dir, rhs,all.bin = TRUE,num.bin.solns = 100) 
  cat(" Done")
  numcols <- nrow(run)
  numsols <- sol$num.bin.solns
  
  solutions <- matrix(head(sol$solution, numcols*numsols), nrow=numsols, byrow=TRUE)
  
  run$Picked <- solutions[1,]
  FINAL <-run[which(run$Picked==1),]
  
  bar <- data.frame(colSums(solutions))
  run$Type<-rep(0,nrow(run))
  run[which(bar==0),"Type"] <- 'No'
  run[which(bar!=nrow(solutions) & bar!=0 ),"Type"] <- 'Maybe'
  run[which(bar==nrow(solutions)),"Type"] <- 'Yes'
  
  print(ggplot(run,aes(x = peakgroup_rt, y = LOBdbase_mz,color=Type)) +
        scale_color_manual(values=c("#e7cd08", "#e70808", "#08e799")) +
        geom_point() +
        geom_text(label=as.character(run$compound_name),nudge_y = 10,size=2,color="black")+
        ggtitle("lpSolve Screened Data") +
        xlab("Peak Group Retention Time (sec)")+
        ylab("Peak Group m/z")
  )
  
  return[return$match_ID %in% run$match_ID,"lpSolve"] <- run$Type
  }
  }
  return(return)
}

